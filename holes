#!/usr/bin/env python3

import io
import math
import optparse
import os
import sys
from typing import Optional


NULL_CHAR = '_'
FILL_CHAR = 'X'


def sizeof_fmt(num, suffix='B'):
    if num == 0:
        return "0B"
    for unit in ['', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei', 'Zi']:
        if abs(num) < 1024.0:
            return "%3.1f%s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)


def main():
    usage = '''%prog [options] FILE...

Find runs of null bytes in files, print the percentage of blocks that are
filled with content vs empty. By default, the blocks will be dynamically sized
based on the file's total size and the width of the output terminal. Pass -b to
use a fixed block size instead.
'''.rstrip()
    p = optparse.OptionParser(usage=usage)
    p.add_option('-q', '--quiet', dest='verbose', action='store_false',
                 help="Silence visualization", default=True)
    p.add_option('-b', '--blocksize', dest='blocksize', metavar='BYTES',
                 type='int', help='Size of blocks to examine')

    opts, args = p.parse_args()

    filenames = args

    if not filenames:
        p.print_help()
        return 1

    for filename in filenames:
        print_file_info(
            filename=filename,
            print_dots=opts.verbose,
            blocksize=opts.blocksize,
        )

    return 0


def print_file_info(
    filename: str,
    blocksize: Optional[int] = None,
    print_dots: bool = True,
):
    sys.stdout.write(filename)

    filename, count, total, size = count_filled(
        filename=filename, blocksize=blocksize, print_dots=print_dots,
    )

    # technically / 0 is NaN, but 0% makes intuitive sense
    frac = count / total if total > 0 else 0
    print(f"\t{frac:.0%} full of {sizeof_fmt(size)}")


def count_filled(
    filename: str,
    blocksize: Optional[int] = None,
    print_dots: bool = True,
):
    count = 0
    total = 0

    file_size = os.stat(filename).st_size

    if blocksize is None:
        if sys.stdout.isatty():
            max_blocks = os.get_terminal_size().columns - 9
        else:
            max_blocks = 71

        if max_blocks < 1:
            max_blocks = 1

        blocksize = math.ceil(file_size / max_blocks)

    null_comparison = memoryview(b'\0' * blocksize)

    buf = bytearray(blocksize)

    if print_dots:
        sys.stdout.write("\n\t")
        sys.stdout.flush()

    with io.FileIO(filename, 'rb') as fh:
        while True:
            size = fh.readinto(buf)
            if size == 0:
                break

            total += 1

            if buf.startswith(null_comparison[:size], 0, size):
                if print_dots:
                    sys.stdout.write(NULL_CHAR)
                    sys.stdout.flush()
            else:
                count += 1
                if print_dots:
                    sys.stdout.write(FILL_CHAR)
                    sys.stdout.flush()

    if print_dots:
        sys.stdout.write('\n')
        sys.stdout.flush()

    return (filename, count, total, file_size)


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(130)
